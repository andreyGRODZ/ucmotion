/*!
 * UC Motion Core (runtime) v1.3.1
 * Author: andreyGRODZ
 * Homepage: https://andreygrodz.ru
 * Repository: https://github.com/andreyGRODZ/ucmotion
 * License: MIT
 */

(function (w,d){'use strict';

  // ===== guard + reuse previous state (idempotent)
  const PREV = w.UCM || {};
  const REGISTRY = PREV.__REGISTRY instanceof Map ? PREV.__REGISTRY : new Map();
  let CSS_INJECTED_FOR = typeof PREV.__CSS_INJECTED_FOR === 'string' ? PREV.__CSS_INJECTED_FOR : '';

  // -------- defaults (глобальные настройки страницы) --------
  const DEFAULTS = {
    effect:'words',
    randomize:false,
    baseDelay:200,
    delayBetweenLines:60,
    parallelLines:true,
    parallelLineStagger:60,
    letterWordDelay:30,
    threshold:0.4,
    preferBasicDelay:true,
    autoReset:false,

    // ↓ безопасные маски/курсив
    bleedK:   { top:0.20, right:0.20, bottom:0.14, left:0.10 },
    bleedMin: { top:8,    right:12,    bottom:6,    left:6    },
    italicWordPadK:  0.26,
    italicWordPadMin: 12
  };

  // -------- state --------
  let CONFIG = {...DEFAULTS, ...(PREV.defaults||{})};

  // -------- utils: DOM / Tilda / timing --------
  const ready = cb => d.readyState!=='loading' ? cb() : d.addEventListener('DOMContentLoaded',cb);

  // !! Надёжный getAtom: чинит битые атрибуты без пробела
  function getAtomSafe(el){
    if (!el) return null;
    if (el.classList && el.classList.contains('tn-atom')) return el;
    let atom = el.querySelector && el.querySelector('.tn-atom');
    if (atom) return atom;
    // fallback: ищем узел с class, содержащим 'tn-atom'
    const tw = d.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, null);
    while (tw.nextNode()){
      const n = tw.currentNode;
      const cls = (n.getAttribute && (n.getAttribute('class')||''))+'';
      if (cls.indexOf('tn-atom')!==-1) return n;
    }
    return null;
  }

  const toMs=v=>Math.max(0,parseFloat(String(v).replace(',','.'))*1000||0);
  const hasBasic=el=>el?.hasAttribute?.('data-animate-style');
  const readBasicDelay=(el,fallback)=> hasBasic(el)?toMs(el.getAttribute('data-animate-delay')??'0'):fallback;

  function neutralizeBasic(el){
    if(!el)return;
    el.style.transition='none'; el.style.opacity='1'; el.style.transform='none';
    const atom=getAtomSafe(el);
    if(atom){ atom.style.transition='none'; atom.style.opacity='1'; atom.style.transform='none'; }
  }

  function injectBasicNeutralizerFor(selectors){
    if(!selectors || !selectors.length) return;
    const key=selectors.slice().sort().join('|');
    if(key===CSS_INJECTED_FOR) return;
    CSS_INJECTED_FOR=key;
    const css=`
      ${selectors.map(s=>`${s}.t-animate,${s}.t-animate_wait,${s}.t-animate_started`).join(',')}{opacity:1!important;transform:none!important;transition:none!important;}
      ${selectors.map(s=>`${s} [data-animate-style],${s} [data-animate-sbs-opts]`).join(',')}{animation:none!important;transition:none!important;}
      ${selectors.map(s=>`${s} .tn-atom`).join(',')}{opacity:1!important;transform:none!important;transition:none!important;display:inline-block;overflow:hidden;}
      .uc-line{display:block;overflow:hidden;line-height:inherit;
        padding: var(--uc-bleed-top,0) var(--uc-bleed-right,0) var(--uc-bleed-bottom,0) var(--uc-bleed-left,0);
        margin:  calc(var(--uc-bleed-top,0) * -1) calc(var(--uc-bleed-right,0) * -1) calc(var(--uc-bleed-bottom,0) * -1) calc(var(--uc-bleed-left,0) * -1);
      }
      .uc-line.uc-gap{margin-top:0;}
      .uc-word,.uc-space,.uc-letter{display:inline-block;white-space:pre;will-change:opacity,transform,filter;backface-visibility:hidden;-webkit-font-smoothing:antialiased;overflow:visible;}
      .uc-italic-fix{--uc-i-pad:0px;padding-right:var(--uc-i-pad);margin-right:calc(var(--uc-i-pad) * -1);}
    `.replace(/\s+/g,' ');
    const tag=d.createElement('style'); tag.type='text/css'; tag.appendChild(d.createTextNode(css)); d.head.appendChild(tag);
  }

  // -------- utils: split & lines --------
  function splitWithEntities(text){
    return text.replace(/&[a-zA-Z0-9#]+;/g,'|$&|').split('|').flatMap(p=>(p.length>1 && /^&.*;$/.test(p))?[p]:[...p]);
  }

  function expandItalicWords(root){
    const words=[...root.querySelectorAll('.uc-word')];
    words.forEach(w=>{
      const cs=getComputedStyle(w);
      const italic=(cs.fontStyle||'').toLowerCase();
      if(!(italic.includes('italic')||italic.includes('oblique'))) return;
      const fs=parseFloat(cs.fontSize)||16;
      const pad=Math.max(Math.ceil(fs*CONFIG.italicWordPadK), CONFIG.italicWordPadMin);
      w.classList.add('uc-italic-fix');
      w.style.setProperty('--uc-i-pad', pad+'px');
    });
  }

  function ensureWrapped(atom,mode){
    if(!atom||atom.__ucWrapped)return;
    const html=atom.innerHTML.replace(/\[gap\]/g,'<span class="__gap-marker"></span>');
    const parts=html.replace(/(<[^>]+>)/g,'|$1|').split('|').filter(Boolean);
    let out='';
    for(const part of parts){
      if(part==='<span class="__gap-marker"></span>' || /^<br\s*\/?>$/i.test(part)){ out+=part; continue; }
      if(part.startsWith('<')&&part.endsWith('>')){ out+=part; continue; }
      const tokens=part.split(/(\u00A0| )/);
      for(const tok of tokens){
        if(tok==='\u00A0'||tok===' ') out+=`<span class="uc-space">${tok}</span>`;
        else if(mode==='letters'){
          const letters=splitWithEntities(tok).map(ch=>`<span class="uc-letter">${ch}</span>`).join('');
          out+=`<span class="uc-word">${letters}</span>`;
        } else out+=`<span class="uc-word">${tok}</span>`;
      }
    }

    const vis=atom.style.visibility;
    atom.style.visibility='hidden';
    atom.innerHTML=out;

    requestAnimationFrame(()=>{
      expandItalicWords(atom);

      const kids=[...atom.childNodes]; const lines=[]; let row=[],top=null;
      for(const node of kids){
        if(node.nodeType===1 && node.classList?.contains('__gap-marker')){
          if(row.length)lines.push({nodes:row,isGap:false});
          lines.push({nodes:null,isGap:true}); row=[]; top=null; continue;
        }
        if(!(node instanceof Element)) continue;
        if(node.tagName==='BR') continue;
        const t=node.offsetTop; if(top===null) top=t;
        if(t!==top){ lines.push({nodes:row,isGap:false}); row=[]; top=t; }
        row.push(node);
      }
      if(row.length)lines.push({nodes:row,isGap:false});

      atom.innerHTML='';
      for(const item of lines){
        const div=d.createElement('div'); div.className='uc-line';
        if(item.isGap){ 
          div.classList.add('uc-gap'); div.innerHTML='&nbsp;';
        } else {
          const first = item.nodes.find(n=>n.nodeType===1);
          const fs = parseFloat(getComputedStyle(first||atom).fontSize) || 16;
          const bt = Math.max(Math.ceil(fs*CONFIG.bleedK.top),    CONFIG.bleedMin.top);
          const br = Math.max(Math.ceil(fs*CONFIG.bleedK.right),  CONFIG.bleedMin.right);
          const bb = Math.max(Math.ceil(fs*CONFIG.bleedK.bottom), CONFIG.bleedMin.bottom);
          const bl = Math.max(Math.ceil(fs*CONFIG.bleedK.left),   CONFIG.bleedMin.left);
          div.style.setProperty('--uc-bleed-top',    bt+'px');
          div.style.setProperty('--uc-bleed-right',  br+'px');
          div.style.setProperty('--uc-bleed-bottom', bb+'px');
          div.style.setProperty('--uc-bleed-left',   bl+'px');
          item.nodes.forEach(n=>div.appendChild(n));
        }
        atom.appendChild(div);
      }

      atom.style.visibility=vis||'visible';
      atom.__ucWrapped=mode||'words';
      atom.__ucLinesBuilt=true;
    });
  }

  // -------- utils: тумблеры/юнит --------
  function readTogglesFrom(el, baseCfg){
    const o={...baseCfg}; const cls=[...el.classList];
    const has=x=>el.classList.contains(x); const hit=re=>cls.find(c=>re.test(c));
    if(has('uc-unit-lines')) o.effect='lines';
    if(has('uc-unit-words')) o.effect='words';
    if(has('uc-unit-letters')) o.effect='letters';
    if(has('uc-order-chaos')) o.randomize=true;
    if(has('uc-lines-serial')) o.parallelLines=false;

    const stg=hit(/^uc-stagger-(\d+)$/);   if(stg) o.letterWordDelay=+stg.split('-').pop();
    const thr=hit(/^uc-threshold-(\d+)$/); if(thr) o.threshold=Math.min(1,Math.max(0,+thr.split('-').pop()/100));
    return o;
  }
  const decideUnit=cfg=> (cfg.effect==='letters'?'letters':(cfg.effect==='lines'?'lines':'words'));

  // -------- utils: планировщик --------
  function scheduleByLines(atom,cfg,unit,cb){
    // если по какой-то причине .uc-line ещё нет — попробуем мягко подстроиться
    let all=[...atom.querySelectorAll('.uc-line')];
    if (!all.length) {
      // соберём «строки» сами по offsetTop
      const items=[...atom.querySelectorAll('.uc-word,.uc-space,.uc-letter')];
      const lines=[]; let top=null, row=[];
      items.forEach(n=>{
        const t=n.offsetTop;
        if(top===null || Math.abs(t-top)<=1){ row.push(n); if(top===null) top=t; }
        else { lines.push(row); row=[n]; top=t; }
      });
      if(row.length) lines.push(row);
      // передадим как будто это «по линиям»
      let cumulative=0;
      lines.forEach((line,i)=>{
        const targets = unit==='letters' ? line.filter(n=>n.classList.contains('uc-letter'))
                      : unit==='words'   ? line.filter(n=>n.classList.contains('uc-word')||n.classList.contains('uc-space'))
                                         : line;
        const unitDelay = unit==='lines'?0:cfg.letterWordDelay;
        let order=targets.map((_,k)=>k); if(cfg.randomize) order.sort(()=>Math.random()-0.5);
        const lineDelay = cfg.parallelLines ? (cumulative + i*cfg.parallelLineStagger) : cumulative;
        targets.forEach((t,j)=>{ const idx=cfg.randomize?order[j]:j; cb(t, lineDelay + idx*unitDelay); });
        if(!cfg.parallelLines){
          cumulative += unit==='lines' ? cfg.delayBetweenLines : (targets.length*unitDelay + cfg.delayBetweenLines);
        }
      });
      return;
    }

    // стандартный путь (есть .uc-line)
    let cumulative=0;
    all.forEach((line,i)=>{
      const targets = unit==='letters' ? [...line.querySelectorAll('.uc-letter')]
                    : unit==='words'   ? [...line.querySelectorAll('.uc-word,.uc-space')]
                                       : [line];
      const unitDelay = unit==='lines'?0:cfg.letterWordDelay;
      let order=targets.map((_,k)=>k); if(cfg.randomize) order.sort(()=>Math.random()-0.5);
      const lineDelay = cfg.parallelLines ? (cumulative + i*cfg.parallelLineStagger) : cumulative;

      targets.forEach((t,j)=>{ const idx=cfg.randomize?order[j]:j; cb(t, lineDelay + idx*unitDelay); });

      if(!cfg.parallelLines){
        cumulative += unit==='lines' ? cfg.delayBetweenLines : (targets.length*unitDelay + cfg.delayBetweenLines);
      }
    });
  }

  // -------- public API --------
  const UCM={
    version:'1.3.1',
    author:'andreyGRODZ',
    homepage:'https://andreygrodz.ru',
    repository:'https://github.com/andreyGRODZ/ucmotion',
    defaults:{...CONFIG},

    // промис готовности (DOM + Tilda)
    ready: (function(){
      let resolved=false;
      return new Promise(res=>{
        const fire=()=>{ if(resolved) return; resolved=true; res(); };
        if (d.readyState!=='loading') setTimeout(fire,0);
        else d.addEventListener('DOMContentLoaded', ()=>setTimeout(fire,0), {once:true});
        d.addEventListener('tilda:blocks:rendered', ()=>setTimeout(fire,0), {once:true});
      });
    })(),

    config(overrides={}){ CONFIG={...CONFIG,...overrides}; this.defaults={...CONFIG}; return this; },

    register(selector,handlers){
      if(!selector||!handlers||typeof handlers.prepare!=='function'||typeof handlers.run!=='function') return this;
      REGISTRY.set(selector,handlers); return this;
    },

    unregister(selector){
      REGISTRY.delete(selector); return this;
    },

    init(selector){
      // neutralize basic разово для всех селекторов, что уже зарегистрированы
      injectBasicNeutralizerFor([...REGISTRY.keys()]);

      // собрать элементы под инициализацию
      const entries = selector
        ? [...d.querySelectorAll(selector)].map(el=>({el,sel:[...REGISTRY.keys()].find(s=>el.matches(s))})).filter(x=>x.sel)
        : [...REGISTRY.keys()].flatMap(sel=>[...d.querySelectorAll(sel)].map(el=>({sel,el})));

      entries.forEach(({sel,el})=>{
        if(el.__ucRan) return;
        const atom=getAtomSafe(el); if(!atom) return;
        const cfg=readTogglesFrom(el, CONFIG);

        const utilApi = this.util;

        try { REGISTRY.get(sel).prepare(el,cfg,utilApi); }
        catch(e){ console.warn('[UCM] prepare', e); }

        const start=()=>{ if(el.__ucRan) return;
          if(!atom.__ucLinesBuilt){ requestAnimationFrame(start); return; }
          el.__ucRan=true; neutralizeBasic(el);
          try { REGISTRY.get(sel).run(el,cfg,utilApi); }
          catch(e){ console.warn('[UCM] run', e); }
        };

        const delay = cfg.preferBasicDelay ? readBasicDelay(el, cfg.baseDelay) : cfg.baseDelay;
        const io=new IntersectionObserver(ents=>{
          ents.forEach(ent=>{
            if(!ent.isIntersecting) return;
            setTimeout(()=>{ start(); io.unobserve(el); }, delay);
          });
        },{threshold:[0,cfg.threshold,1]});
        io.observe(el);

        if(cfg.autoReset && typeof REGISTRY.get(sel).reset==='function'){
          const io2=new IntersectionObserver(ents=>{
            ents.forEach(ent=>{
              if(!ent.isIntersecting && el.__ucRan){
                el.__ucRan=false; try{ REGISTRY.get(sel).reset(el,cfg,utilApi); }catch(_){}
                io.observe(el);
              }
            });
          },{threshold:[0,0.01]});
          io2.observe(el);
        }
      });
      return this;
    },

    util:{
      ready, getAtom:getAtomSafe, toMs, hasBasic, readBasicDelay,
      neutralizeBasic, injectBasicNeutralizerFor,
      splitWithEntities, ensureWrapped, scheduleByLines, decideUnit, readTogglesFrom
    },

    // внутренние маркеры для повторных подключений
    __REGISTRY: REGISTRY,
    __CSS_INJECTED_FOR: CSS_INJECTED_FOR,
    __coreLoaded: true
  };

  (function banner(){
    if (w.__UCM_BANNER__) return;
    w.__UCM_BANNER__ = true;
    try {
      console.log('%cUC Motion v'+UCM.version+' — by '+UCM.author+'  |  '+UCM.repository,
        'color:#25EDFF;font-weight:600;');
    } catch(_) {}
  })();

  w.UCM=UCM;
})(window,document);

/*!
 * UC Motion Core (runtime) v1.2.0
 * Author: andreyGRODZ
 * Homepage: https://andreygrodz.ru
 * Repository: https://github.com/andreyGRODZ/ucmotion
 * License: MIT
 */

(function (w,d){'use strict';

  // ===== guard (idempotent) =====
  const PREV = w.UCM || {};
  const REGISTRY = PREV.__REGISTRY instanceof Map ? PREV.__REGISTRY : new Map();
  let CSS_INJECTED_FOR = typeof PREV.__CSS_INJECTED_FOR === 'string' ? PREV.__CSS_INJECTED_FOR : '';

  // -------- defaults --------
  const DEFAULTS = {
    effect:'words',            // 'lines' | 'words' | 'letters'
    randomize:false,           // хаотичный порядок
    baseDelay:200,             // задержка (ms)
    delayBetweenLines:60,      // задержка между строками
    parallelLines:true,        // true = параллельно, false = последовательно
    parallelLineStagger:60,    // шаг для параллельных строк
    letterWordDelay:30,        // шаг между буквами/словами
    threshold:0.4,             // доля видимости для старта
    preferBasicDelay:true,     // брать delay из Tilda Basic
    autoReset:false            // сброс при уходе из viewport
  };

  let CONFIG = {...DEFAULTS, ...(PREV.defaults||{})};

  // -------- utils --------
  const ready = cb => d.readyState!=='loading' ? cb() : d.addEventListener('DOMContentLoaded',cb);

  function getAtomSafe(el){
    if (!el) return null;
    if (el.classList && el.classList.contains('tn-atom')) return el;
    return el.querySelector?.('.tn-atom') || null;
  }

  const toMs=v=>Math.max(0,parseFloat(String(v).replace(',','.'))*1000||0);
  const hasBasic=el=>el?.hasAttribute?.('data-animate-style');
  const readBasicDelay=(el,fallback)=> hasBasic(el)?toMs(el.getAttribute('data-animate-delay')??'0'):fallback;

  function neutralizeBasic(el){
    if(!el)return;
    el.style.transition='none'; el.style.opacity='1'; el.style.transform='none';
    const atom=getAtomSafe(el);
    if(atom){ atom.style.transition='none'; atom.style.opacity='1'; atom.style.transform='none'; }
  }

  function injectBasicNeutralizerFor(selectors){
    if(!selectors || !selectors.length) return;
    const key=selectors.slice().sort().join('|');
    if(key===CSS_INJECTED_FOR) return;
    CSS_INJECTED_FOR=key;
    const css=`
      ${selectors.map(s=>`${s}.t-animate,${s}.t-animate_wait,${s}.t-animate_started`).join(',')}
        {opacity:1!important;transform:none!important;transition:none!important;}
      ${selectors.map(s=>`${s} [data-animate-style],${s} [data-animate-sbs-opts]`).join(',')}
        {animation:none!important;transition:none!important;}
      ${selectors.map(s=>`${s} .tn-atom`).join(',')}
        {opacity:1!important;transform:none!important;transition:none!important;display:inline-block;overflow:hidden;}
      .uc-line{display:block;overflow:hidden;line-height:inherit;}
      .uc-line.uc-gap{margin-top:0;}
      .uc-word,.uc-space,.uc-letter{display:inline-block;white-space:pre;will-change:opacity,transform,filter;}
    `.replace(/\s+/g,' ');
    const tag=d.createElement('style'); tag.type='text/css'; tag.appendChild(d.createTextNode(css)); d.head.appendChild(tag);
  }

  // -------- split / lines --------
  function splitWithEntities(text){
    return text.replace(/&[a-zA-Z0-9#]+;/g,'|$&|').split('|')
      .flatMap(p=>(p.length>1 && /^&.*;$/.test(p))?[p]:[...p]);
  }

  function ensureWrapped(atom,mode){
    if(!atom||atom.__ucWrapped) return;
    const html=atom.innerHTML.replace(/\[gap\]/g,'<span class="__gap-marker"></span>');
    const parts=html.replace(/(<[^>]+>)/g,'|$1|').split('|').filter(Boolean);
    let out='';
    for(const part of parts){
      if(part==='<span class="__gap-marker"></span>' || /^<br\s*\/?>$/i.test(part)){ out+=part; continue; }
      if(part.startsWith('<')&&part.endsWith('>')){ out+=part; continue; }
      const tokens=part.split(/(\u00A0| )/);
      for(const tok of tokens){
        if(tok==='\u00A0'||tok===' ') out+=`<span class="uc-space">${tok}</span>`;
        else if(mode==='letters'){
          const letters=splitWithEntities(tok).map(ch=>`<span class="uc-letter">${ch}</span>`).join('');
          out+=`<span class="uc-word">${letters}</span>`;
        } else out+=`<span class="uc-word">${tok}</span>`;
      }
    }

    const vis=atom.style.visibility;
    atom.style.visibility='hidden';
    atom.innerHTML=out;

    requestAnimationFrame(()=>{
      const kids=[...atom.childNodes]; const lines=[]; let row=[],top=null;
      for(const node of kids){
        if(node.nodeType===1 && node.classList?.contains('__gap-marker')){
          if(row.length)lines.push({nodes:row,isGap:false});
          lines.push({nodes:null,isGap:true}); row=[]; top=null; continue;
        }
        if(!(node instanceof Element)) continue;
        if(node.tagName==='BR') continue;
        const t=node.offsetTop; if(top===null) top=t;
        if(t!==top){ lines.push({nodes:row,isGap:false}); row=[]; top=t; }
        row.push(node);
      }
      if(row.length)lines.push({nodes:row,isGap:false});

      atom.innerHTML='';
      for(const item of lines){
        const div=d.createElement('div'); div.className='uc-line';
        if(item.isGap){ div.classList.add('uc-gap'); div.innerHTML='&nbsp;'; }
        else { item.nodes.forEach(n=>div.appendChild(n)); }
        atom.appendChild(div);
      }

      atom.style.visibility=vis||'visible';
      atom.__ucWrapped=mode||'words';
      atom.__ucLinesBuilt=true;
    });
  }

  function readTogglesFrom(el, baseCfg){
    const o={...baseCfg}; const cls=[...el.classList];
    const has=x=>el.classList.contains(x); const hit=re=>cls.find(c=>re.test(c));
    if(has('uc-unit-lines')) o.effect='lines';
    if(has('uc-unit-words')) o.effect='words';
    if(has('uc-unit-letters')) o.effect='letters';
    if(has('uc-order-chaos')) o.randomize=true;
    if(has('uc-lines-serial')) o.parallelLines=false;
    const stg=hit(/^uc-stagger-(\d+)$/);   if(stg) o.letterWordDelay=+stg.split('-').pop();
    const thr=hit(/^uc-threshold-(\d+)$/); if(thr) o.threshold=Math.min(1,Math.max(0,+thr.split('-').pop()/100));
    return o;
  }
  const decideUnit=cfg=> (cfg.effect==='letters'?'letters':(cfg.effect==='lines'?'lines':'words'));

  function scheduleByLines(atom,cfg,unit,cb){
    let all=[...atom.querySelectorAll('.uc-line')];
    let cumulative=0;
    all.forEach((line,i)=>{
      const targets = unit==='letters' ? [...line.querySelectorAll('.uc-letter')]
                    : unit==='words'   ? [...line.querySelectorAll('.uc-word,.uc-space')]
                                       : [line];
      const unitDelay = unit==='lines'?0:cfg.letterWordDelay;
      let order=targets.map((_,k)=>k); if(cfg.randomize) order.sort(()=>Math.random()-0.5);
      const lineDelay = cfg.parallelLines ? (cumulative + i*cfg.parallelLineStagger) : cumulative;
      targets.forEach((t,j)=>{ const idx=cfg.randomize?order[j]:j; cb(t, lineDelay + idx*unitDelay); });
      if(!cfg.parallelLines){
        cumulative += unit==='lines' ? cfg.delayBetweenLines : (targets.length*unitDelay + cfg.delayBetweenLines);
      }
    });
  }

  // -------- public API --------
  const UCM={
    version:'1.2.0',
    author:'andreyGRODZ',
    homepage:'https://andreygrodz.ru',
    repository:'https://github.com/andreyGRODZ/ucmotion',
    defaults:{...CONFIG},

    ready:(function(){let r=false;return new Promise(res=>{const f=()=>{if(r)return;r=true;res();};if(d.readyState!=='loading')setTimeout(f,0);else d.addEventListener('DOMContentLoaded',()=>setTimeout(f,0),{once:true});d.addEventListener('tilda:blocks:rendered',()=>setTimeout(f,0),{once:true});});})(),

    config(overrides={}){ CONFIG={...CONFIG,...overrides}; this.defaults={...CONFIG}; return this; },

    register(selector,handlers){ if(!selector||!handlers||typeof handlers.prepare!=='function'||typeof handlers.run!=='function') return this; REGISTRY.set(selector,handlers); return this; },
    unregister(selector){ REGISTRY.delete(selector); return this; },

    init(selector){
      injectBasicNeutralizerFor([...REGISTRY.keys()]);
      const entries = selector
        ? [...d.querySelectorAll(selector)].map(el=>({el,sel:[...REGISTRY.keys()].find(s=>el.matches(s))})).filter(x=>x.sel)
        : [...REGISTRY.keys()].flatMap(sel=>[...d.querySelectorAll(sel)].map(el=>({sel,el})));
      entries.forEach(({sel,el})=>{
        if(el.__ucRan) return;
        const atom=getAtomSafe(el); if(!atom) return;
        const cfg=readTogglesFrom(el, CONFIG);
        try { REGISTRY.get(sel).prepare(el,cfg,this.util); } catch(e){ }
        const start=()=>{ if(el.__ucRan) return; if(!atom.__ucLinesBuilt){ requestAnimationFrame(start); return; } el.__ucRan=true; neutralizeBasic(el); try { REGISTRY.get(sel).run(el,cfg,this.util); } catch(e){ } };
        const delay = cfg.preferBasicDelay ? readBasicDelay(el, cfg.baseDelay) : cfg.baseDelay;
        const io=new IntersectionObserver(ents=>{ ents.forEach(ent=>{ if(!ent.isIntersecting) return; setTimeout(()=>{ start(); io.unobserve(el); }, delay); }); },{threshold:[0,cfg.threshold,1]}); io.observe(el);
        if(cfg.autoReset && typeof REGISTRY.get(sel).reset==='function'){ const io2=new IntersectionObserver(ents=>{ ents.forEach(ent=>{ if(!ent.isIntersecting && el.__ucRan){ el.__ucRan=false; try{ REGISTRY.get(sel).reset(el,cfg,this.util); }catch(_){ } io.observe(el);} }); },{threshold:[0,0.01]}); io2.observe(el); }
      });
      return this;
    },

    util:{ready,getAtom:getAtomSafe,toMs,hasBasic,readBasicDelay,neutralizeBasic,injectBasicNeutralizerFor,splitWithEntities,ensureWrapped,scheduleByLines,decideUnit,readTogglesFrom},

    __REGISTRY:REGISTRY,
    __CSS_INJECTED_FOR:CSS_INJECTED_FOR,
    __coreLoaded:true
  };

  (function banner(){
    if (w.__UCM_BANNER__) return;
    w.__UCM_BANNER__=true;
    try { console.log('%cUC Motion v'+UCM.version+' — by '+UCM.author,'color:#25EDFF;font-weight:600;'); } catch(_) {}
  })();

  w.UCM=UCM;
})(window,document);

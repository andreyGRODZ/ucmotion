/*!
 * UC Motion Core (runtime) v1.3.0
 * Author: andreyGRODZ
 * Homepage: https://andreygrodz.ru
 * Repository: https://github.com/andreyGRODZ/ucmotion
 * License: MIT
 */

(function (w,d){'use strict';

  // -------- defaults (глобальные настройки страницы) --------
  const DEFAULTS = {
    effect:'words',
    randomize:false,
    baseDelay:200,
    delayBetweenLines:60,
    parallelLines:true,
    parallelLineStagger:60,
    letterWordDelay:30,
    threshold:0.4,
    preferBasicDelay:true,
    autoReset:false,

    // ↓ Новое: параметры безопасных масок/курсива
    bleedK:   { top:0.20, right:0.20, bottom:0.14, left:0.10 },
    bleedMin: { top:8,    right:12,    bottom:6,    left:6    },
    italicWordPadK:  0.26, // 26% от кегля → padding-right у курсивного слова
    italicWordPadMin: 12   // минимум в px
  };

  // -------- state --------
  const REGISTRY=new Map();
  let CONFIG={...DEFAULTS};
  let CSS_INJECTED_FOR='';

  // -------- utils: DOM / Tilda / timing --------
  const ready=cb=>d.readyState!=='loading'?cb():d.addEventListener('DOMContentLoaded',cb);
  const getAtom=el=> (el?.classList?.contains('tn-atom')?el:el?.querySelector?.('.tn-atom'))||null;
  const toMs=v=>Math.max(0,parseFloat(String(v).replace(',','.'))*1000||0);
  const hasBasic=el=>el?.hasAttribute?.('data-animate-style');
  const readBasicDelay=(el,fallback)=> hasBasic(el)?toMs(el.getAttribute('data-animate-delay')??'0'):fallback;

  function neutralizeBasic(el){
    if(!el)return;
    el.style.transition='none'; el.style.opacity='1'; el.style.transform='none';
    const atom=getAtom(el);
    if(atom){ atom.style.transition='none'; atom.style.opacity='1'; atom.style.transform='none'; }
  }

  function injectBasicNeutralizerFor(selectors){
    const key=selectors.sort().join('|'); if(key===CSS_INJECTED_FOR||!selectors.length)return;
    CSS_INJECTED_FOR=key;
    const css=`
      ${selectors.map(s=>`${s}.t-animate,${s}.t-animate_wait,${s}.t-animate_started`).join(',')}{opacity:1!important;transform:none!important;transition:none!important;}
      ${selectors.map(s=>`${s} .tn-atom`).join(',')}{opacity:1!important;transform:none!important;transition:none!important;display:inline-block;overflow:hidden;}
      .uc-line{display:block;overflow:hidden;line-height:inherit;
        /* безопасные маски: расширяем реальный бокс строки внутрь/наружу */
        padding: var(--uc-bleed-top,0) var(--uc-bleed-right,0) var(--uc-bleed-bottom,0) var(--uc-bleed-left,0);
        margin:  calc(var(--uc-bleed-top,0) * -1) calc(var(--uc-bleed-right,0) * -1) calc(var(--uc-bleed-bottom,0) * -1) calc(var(--uc-bleed-left,0) * -1);
      }
      .uc-line.uc-gap{margin-top:0;}
      .uc-word,.uc-space,.uc-letter{display:inline-block;white-space:pre;will-change:opacity,transform,filter;backface-visibility:hidden;-webkit-font-smoothing:antialiased;overflow:visible;}
      /* ГЛАВНОЕ: расширение бокса курсивного слова (Safari fix) */
      .uc-italic-fix{--uc-i-pad:0px;padding-right:var(--uc-i-pad);margin-right:calc(var(--uc-i-pad) * -1);}
    `.replace(/\s+/g,' ');
    const tag=d.createElement('style'); tag.type='text/css'; tag.appendChild(d.createTextNode(css)); d.head.appendChild(tag);
  }

  // -------- utils: split & lines --------
  function splitWithEntities(text){
    return text.replace(/&[a-zA-Z0-9#]+;/g,'|$&|').split('|').flatMap(p=>(p.length>1 && /^&.*;$/.test(p))?[p]:[...p]);
  }

  // расширяем боксы курсивных слов (перед постройкой строк)
  function expandItalicWords(root){
    const words=[...root.querySelectorAll('.uc-word')];
    words.forEach(w=>{
      const cs=getComputedStyle(w);
      const italic=(cs.fontStyle||'').toLowerCase(); 
      if(!(italic.includes('italic')||italic.includes('oblique'))) return;
      const fs=parseFloat(cs.fontSize)||16;
      const pad=Math.max(Math.ceil(fs*CONFIG.italicWordPadK), CONFIG.italicWordPadMin);
      w.classList.add('uc-italic-fix');
      w.style.setProperty('--uc-i-pad', pad+'px');
    });
  }

  function ensureWrapped(atom,mode){
    if(!atom||atom.__ucWrapped)return;
    const html=atom.innerHTML.replace(/\[gap\]/g,'<span class="__gap-marker"></span>');
    const parts=html.replace(/(<[^>]+>)/g,'|$1|').split('|').filter(Boolean);
    let out='';
    for(const part of parts){
      // ✅ ловим <br>, <br/>, <br /> (любые пробелы и регистр)
      if(part==='<span class="__gap-marker"></span>' || /^<br\s*\/?>$/i.test(part)){ out+=part; continue; }
      if(part.startsWith('<')&&part.endsWith('>')){ out+=part; continue; }
      const tokens=part.split(/(\u00A0| )/);
      for(const tok of tokens){
        if(tok==='\u00A0'||tok===' ') out+=`<span class="uc-space">${tok}</span>`;
        else if(mode==='letters'){
          const letters=splitWithEntities(tok).map(ch=>`<span class="uc-letter">${ch}</span>`).join('');
          out+=`<span class="uc-word">${letters}</span>`;
        } else out+=`<span class="uc-word">${tok}</span>`;
      }
    }

    const vis=atom.style.visibility;
    atom.style.visibility='hidden';
    atom.innerHTML=out;

    requestAnimationFrame(()=>{
      expandItalicWords(atom);

      const kids=[...atom.childNodes]; const lines=[]; let row=[],top=null;
      for(const node of kids){
        if(node.nodeType===1 && node.classList?.contains('__gap-marker')){
          if(row.length)lines.push({nodes:row,isGap:false});
          lines.push({nodes:null,isGap:true}); row=[]; top=null; continue;
        }
        if(!(node instanceof Element)) continue;
        if(node.tagName==='BR') continue;
        const t=node.offsetTop; if(top===null) top=t;
        if(t!==top){ lines.push({nodes:row,isGap:false}); row=[]; top=t; }
        row.push(node);
      }
      if(row.length)lines.push({nodes:row,isGap:false});

      atom.innerHTML='';
      for(const item of lines){
        const div=d.createElement('div'); div.className='uc-line';
        if(item.isGap){ 
          div.classList.add('uc-gap'); div.innerHTML='&nbsp;';
        } else {
          const first = item.nodes.find(n=>n.nodeType===1);
          const fs = parseFloat(getComputedStyle(first||atom).fontSize) || 16;
          const bt = Math.max(Math.ceil(fs*CONFIG.bleedK.top),    CONFIG.bleedMin.top);
          const br = Math.max(Math.ceil(fs*CONFIG.bleedK.right),  CONFIG.bleedMin.right);
          const bb = Math.max(Math.ceil(fs*CONFIG.bleedK.bottom), CONFIG.bleedMin.bottom);
          const bl = Math.max(Math.ceil(fs*CONFIG.bleedK.left),   CONFIG.bleedMin.left);
          div.style.setProperty('--uc-bleed-top',    bt+'px');
          div.style.setProperty('--uc-bleed-right',  br+'px');
          div.style.setProperty('--uc-bleed-bottom', bb+'px');
          div.style.setProperty('--uc-bleed-left',   bl+'px');
          item.nodes.forEach(n=>div.appendChild(n));
        }
        atom.appendChild(div);
      }

      atom.style.visibility=vis||'visible';
      atom.__ucWrapped=mode||'words';
      atom.__ucLinesBuilt=true;
    });
  }

  // -------- utils: тумблеры/юнит --------
  function readTogglesFrom(el, baseCfg){
    const o={...baseCfg}; const cls=[...el.classList];
    const has=x=>el.classList.contains(x); const hit=re=>cls.find(c=>re.test(c));
    if(has('uc-unit-lines')) o.effect='lines';
    if(has('uc-unit-words')) o.effect='words';
    if(has('uc-unit-letters')) o.effect='letters';
    if(has('uc-order-chaos')) o.randomize=true;
    if(has('uc-lines-serial')) o.parallelLines=false;

    const stg=hit(/^uc-stagger-(\d+)$/);   if(stg) o.letterWordDelay=+stg.split('-').pop();
    const thr=hit(/^uc-threshold-(\d+)$/); if(thr) o.threshold=Math.min(1,Math.max(0,+thr.split('-').pop()/100));
    return o;
  }
  const decideUnit=cfg=> (cfg.effect==='letters'?'letters':(cfg.effect==='lines'?'lines':'words'));

  // -------- utils: планировщик --------
  function scheduleByLines(atom,cfg,unit,cb){
    const all=[...atom.querySelectorAll('.uc-line')]; let cumulative=0;
    all.forEach((line,i)=>{
      const targets = unit==='letters' ? [...line.querySelectorAll('.uc-letter')]
                    : unit==='words'   ? [...line.querySelectorAll('.uc-word,.uc-space')]
                                       : [line];
      const unitDelay = unit==='lines'?0:cfg.letterWordDelay;
      let order=targets.map((_,k)=>k); if(cfg.randomize) order.sort(()=>Math.random()-0.5);
      const lineDelay = cfg.parallelLines ? (cumulative + i*cfg.parallelLineStagger) : cumulative;

      targets.forEach((t,j)=>{ const idx=cfg.randomize?order[j]:j; cb(t, lineDelay + idx*unitDelay); });

      if(!cfg.parallelLines){
        cumulative += unit==='lines' ? cfg.delayBetweenLines : (targets.length*unitDelay + cfg.delayBetweenLines);
      }
    });
  }

  // -------- public API --------
  const UCM={
    version:'1.3.0',
    author:'andreyGRODZ',
    homepage:'https://andreygrodz.ru',
    repository:'https://github.com/andreyGRODZ/ucmotion',
    defaults:{...DEFAULTS},

    config(overrides={}){ CONFIG={...CONFIG,...overrides}; this.defaults={...CONFIG}; return this; },

    register(selector,handlers){
      if(!selector||!handlers||typeof handlers.prepare!=='function'||typeof handlers.run!=='function') return this;
      REGISTRY.set(selector,handlers); return this;
    },

    init(selector){
      injectBasicNeutralizerFor([...REGISTRY.keys()]);
      const entries = selector
        ? [...d.querySelectorAll(selector)].map(el=>({el,sel:[...REGISTRY.keys()].find(s=>el.matches(s))})).filter(x=>x.sel)
        : [...REGISTRY.keys()].flatMap(sel=>[...d.querySelectorAll(sel)].map(el=>({sel,el})));

      entries.forEach(({sel,el})=>{
        if(el.__ucRan) return;
        const atom=getAtom(el); if(!atom) return;
        const cfg=readTogglesFrom(el, CONFIG);

        REGISTRY.get(sel).prepare(el,cfg,this.util);

        const start=()=>{ if(el.__ucRan) return;
          if(!atom.__ucLinesBuilt){ requestAnimationFrame(start); return; }
          el.__ucRan=true; neutralizeBasic(el); REGISTRY.get(sel).run(el,cfg,this.util);
        };

        const delay = cfg.preferBasicDelay ? readBasicDelay(el, cfg.baseDelay) : cfg.baseDelay;
        const io=new IntersectionObserver(ents=>{
          ents.forEach(ent=>{
            if(!ent.isIntersecting) return;
            setTimeout(()=>{ start(); io.unobserve(el); }, delay);
          });
        },{threshold:[0,cfg.threshold,1]});
        io.observe(el);

        if(cfg.autoReset && typeof REGISTRY.get(sel).reset==='function'){
          const io2=new IntersectionObserver(ents=>{
            ents.forEach(ent=>{
              if(!ent.isIntersecting && el.__ucRan){
                el.__ucRan=false; REGISTRY.get(sel).reset(el,cfg,this.util); io.observe(el);
              }
            });
          },{threshold:[0,0.01]});
          io2.observe(el);
        }
      });
      return this;
    },

    util:{
      ready,getAtom,toMs,hasBasic,readBasicDelay,neutralizeBasic,injectBasicNeutralizerFor,
      splitWithEntities,ensureWrapped,scheduleByLines,decideUnit,readTogglesFrom
    }
  };

  (function banner(){
    if (w.__UCM_BANNER__) return;
    w.__UCM_BANNER__ = true;
    try {
      console.log('%cUC Motion v'+UCM.version+' — by '+UCM.author+'  |  '+UCM.repository,
        'color:#25EDFF;font-weight:600;');
    } catch(_) {}
  })();

  w.UCM=UCM;
})(window,document);
</script>

<!-- UC Motion Addon: FontWarmup + SmartFontWait (for v1.3.0) -->
<script>
(function(w,d){
  'use strict';
  if(!w.UCM) return;

  const SEL = new Set();
  const isSafari = /^((?!chrome|android|crios|fxios|edg).)*safari/i.test(navigator.userAgent);
  const onDOM = cb => (d.readyState!=='loading'?cb():d.addEventListener('DOMContentLoaded', cb));
  const getAtom = el => (el?.classList?.contains('tn-atom')?el:el?.querySelector?.('.tn-atom'))||null;

  function prewarmFonts(){
    if(!(document.fonts && document.fonts.load)) return;
    const families = new Set();
    SEL.forEach(sel=>{
      d.querySelectorAll(sel).forEach(el=>{
        const atom=getAtom(el);
        if(!atom) return;
        const fam=(getComputedStyle(atom).fontFamily||'').split(',')[0].trim().replace(/^["']|["']$/g,'');
        if(!fam||families.has(fam)) return;
        families.add(fam);
        try{document.fonts.load(\`16px "\${fam}"\`,' ');}catch(_){}
        try{document.fonts.load(\`24px "\${fam}"\`,' ');}catch(_){}
        try{document.fonts.load(\`40px "\${fam}"\`,' ');}catch(_){}
      });
    });
  }

  function waitForFonts(timeout){
    const cap=(typeof timeout==='number')?timeout:(isSafari?300:0);
    try{ if(sessionStorage.getItem('ucFontsReady')==='1' || cap===0) return Promise.resolve(); }catch(_){}
    const probe=(()=>{for(const sel of SEL){const el=d.querySelector(sel);if(el){const a=getAtom(el);if(a)return a;}}return null;})();
    const fastReady=()=>{
      if(!(window.CSS&&document.fonts&&document.fonts.check)||!probe)return false;
      const fam=(getComputedStyle(probe).fontFamily||'').split(',')[0].trim().replace(/^["']|["']$/g,'');
      try{
        if(fam&&document.fonts.check(\`24px \${fam}\`)){
          try{ sessionStorage.setItem('ucFontsReady','1'); }catch(_){}
          return true;
        }
      }catch(_){}
      return false;
    };
    if(fastReady()) return Promise.resolve();

    if(!(document.fonts&&document.fonts.ready)){
      if(!probe) return Promise.resolve();
      let w0=probe.offsetWidth,t=0;
      return new Promise(res=>{
        const id=setInterval(()=>{
          const w1=probe.offsetWidth;
          if(w1!==w0 || (t+=50)>=cap){ clearInterval(id); res(); }
          w0=w1;
        },50);
      });
    }

    const timer=new Promise(res=>setTimeout(res,cap));
    const readyP=document.fonts.ready.then(()=>{
      try{ sessionStorage.setItem('ucFontsReady','1'); }catch(_){}
    }).catch(()=>{});
    const event=new Promise(res=>{
      try{
        document.fonts.addEventListener('loadingdone',()=>{
          try{ sessionStorage.setItem('ucFontsReady','1'); }catch(_){}
          res();
        },{once:true});
      }catch(_){ res(); }
    });
    return Promise.race([Promise.all([readyP,event]),timer]);
  }

  const _register=w.UCM.register.bind(w.UCM);
  w.UCM.register=function(selector,handlers){ if(selector) SEL.add(selector); return _register(selector,handlers); };

  const _init=w.UCM.init.bind(w.UCM);
  w.UCM.init=function(selector){
    onDOM(()=>{
      try{ prewarmFonts(); }catch(_){}
      waitForFonts().then(()=>{ _init(selector); });
    });
    return this;
  };

  try{ console.log('%cUCM Addon v1.3.0: FontWarmup + SmartFontWait enabled','color:#25EDFF'); }catch(_){}
})(window,document);

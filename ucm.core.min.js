/*!
 * UCM Core (runtime) v1.1.0
 * База для Tilda: BasicDelay-bridge + автоглушение визуала Basic
 * Сплит: letters/words/lines с сохранением <br>, сущностей и [gap] → .uc-line группировка
 * Тумблеры с элемента: uc-unit-*, uc-lines-serial, uc-order-chaos, uc-stagger-XX, uc-threshold-YY
 * API: UCM.config(), UCM.register(selector,{prepare,run,reset?}), UCM.init([selector])
 */
(function (w,d){'use strict';
  // -------- defaults (глобальные настройки страницы) --------
  const DEFAULTS = {
    effect:'words',          // базовый юнит страницы: 'lines'|'words'|'letters' (эффект может переопределить)
    randomize:false,
    baseDelay:200,           // мс, если Basic Animation не включён
    delayBetweenLines:60,    // мс (для последовательных строк)
    parallelLines:true,
    parallelLineStagger:60,  // мс между строками в параллельном режиме
    letterWordDelay:30,      // мс между буквами/словами (если unit ≠ 'lines')
    threshold:0.4,
    preferBasicDelay:true,   // брать таймер из Basic Animation → Delay
    autoReset:false
  };

  // -------- state --------
  const REGISTRY=new Map(); // selector -> {prepare,run,reset?}
  let CONFIG={...DEFAULTS};
  let CSS_INJECTED_FOR='';  // чтобы не дублировать инъекцию

  // -------- utils: DOM / Tilda / timing --------
  const ready=cb=>d.readyState!=='loading'?cb():d.addEventListener('DOMContentLoaded',cb);
  const getAtom=el=> (el?.classList?.contains('tn-atom')?el:el?.querySelector?.('.tn-atom'))||null;
  const toMs=v=>Math.max(0,parseFloat(String(v).replace(',','.'))*1000||0);
  const hasBasic=el=>el?.hasAttribute?.('data-animate-style');
  const readBasicDelay=(el,fallback)=> hasBasic(el)?toMs(el.getAttribute('data-animate-delay')??'0'):fallback;

  function neutralizeBasic(el){
    if(!el)return; el.style.transition='none'; el.style.opacity='1'; el.style.transform='none';
    const atom=getAtom(el); if(atom){ atom.style.transition='none'; atom.style.opacity='1'; atom.style.transform='none'; }
  }

  function injectBasicNeutralizerFor(selectors){
    const key=selectors.sort().join('|'); if(key===CSS_INJECTED_FOR||!selectors.length)return;
    CSS_INJECTED_FOR=key;
    const css=`
      ${selectors.map(s=>`${s}.t-animate,${s}.t-animate_wait,${s}.t-animate_started`).join(',')}{opacity:1!important;transform:none!important;transition:none!important;}
      ${selectors.map(s=>`${s} .tn-atom`).join(',')}{opacity:1!important;transform:none!important;transition:none!important;display:inline-block;overflow:hidden;}
      .uc-line{display:block;overflow:hidden;line-height:inherit;}
      .uc-line.uc-gap{margin-top:0;}
      .uc-word,.uc-space,.uc-letter{display:inline-block;white-space:pre;will-change:opacity,transform,filter;}
    `.replace(/\s+/g,' ');
    const tag=d.createElement('style'); tag.type='text/css'; tag.appendChild(d.createTextNode(css)); d.head.appendChild(tag);
  }

  // -------- utils: split & lines --------
  function splitWithEntities(text){
    return text.replace(/&[a-zA-Z0-9#]+;/g,'|$&|').split('|').flatMap(p=>(p.length>1 && /^&.*;$/.test(p))?[p]:[...p]);
  }

  // mode: 'letters'|'words'|'lines' (в 'lines' всё равно оборачиваем слова и пробелы)
  function ensureWrapped(atom,mode){
    if(!atom||atom.__ucWrapped)return;
    const html=atom.innerHTML.replace(/\[gap\]/g,'<span class="__gap-marker"></span>');
    const parts=html.replace(/(<[^>]+>)/g,'|$1|').split('|').filter(Boolean);
    let out='';
    for(const part of parts){
      if(part==='<span class="__gap-marker"></span>'||part==='<br>'){ out+=part; continue; }
      if(part.startsWith('<')&&part.endsWith('>')){ out+=part; continue; }
      const tokens=part.split(/(\u00A0| )/);
      for(const tok of tokens){
        if(tok==='\u00A0'||tok===' ') out+=`<span class="uc-space">${tok}</span>`;
        else if(mode==='letters'){ const letters=splitWithEntities(tok).map(ch=>`<span class="uc-letter">${ch}</span>`).join(''); out+=`<span class="uc-word">${letters}</span>`; }
        else out+=`<span class="uc-word">${tok}</span>`;
      }
    }
    const vis=atom.style.visibility; atom.style.visibility='hidden'; atom.innerHTML=out;

    // группировка в визуальные строки
    requestAnimationFrame(()=>{
      const kids=[...atom.childNodes]; const lines=[]; let row=[],top=null;
      for(const node of kids){
        if(node.nodeType===1 && node.classList?.contains('__gap-marker')){ if(row.length)lines.push({nodes:row,isGap:false}); lines.push({nodes:null,isGap:true}); row=[]; top=null; continue; }
        if(!(node instanceof Element)) continue;
        if(node.tagName==='BR') continue;
        const t=node.offsetTop; if(top===null) top=t;
        if(t!==top){ lines.push({nodes:row,isGap:false}); row=[]; top=t; }
        row.push(node);
      }
      if(row.length)lines.push({nodes:row,isGap:false});
      atom.innerHTML='';
      for(const item of lines){
        const div=d.createElement('div'); div.className='uc-line';
        if(item.isGap){ div.classList.add('uc-gap'); div.innerHTML='&nbsp;'; }
        else item.nodes.forEach(n=>div.appendChild(n));
        atom.appendChild(div);
      }
      atom.style.visibility=vis||'visible';
      atom.__ucWrapped=mode||'words';
      atom.__ucLinesBuilt=true;
    });
  }

  // -------- utils: тумблеры/юнит --------
  function readTogglesFrom(el, baseCfg){
    const o={...baseCfg}; const cls=[...el.classList];
    const has=x=>el.classList.contains(x); const hit=re=>cls.find(c=>re.test(c));
    if(has('uc-unit-lines')) o.effect='lines';
    if(has('uc-unit-words')) o.effect='words';
    if(has('uc-unit-letters')) o.effect='letters';
    if(has('uc-order-chaos')) o.randomize=true;
    if(has('uc-lines-serial')) o.parallelLines=false;

    const stg=hit(/^uc-stagger-(\d+)$/);   if(stg) o.letterWordDelay=+stg.split('-').pop();
    const thr=hit(/^uc-threshold-(\d+)$/); if(thr) o.threshold=Math.min(1,Math.max(0,+thr.split('-').pop()/100));
    return o;
  }
  const decideUnit=cfg=> (cfg.effect==='letters'?'letters':(cfg.effect==='lines'?'lines':'words'));

  // -------- utils: планировщик --------
  function scheduleByLines(atom,cfg,unit,cb){
    const all=[...atom.querySelectorAll('.uc-line')]; let cumulative=0;
    all.forEach((line,i)=>{
      const targets = unit==='letters' ? [...line.querySelectorAll('.uc-letter')]
                    : unit==='words'   ? [...line.querySelectorAll('.uc-word,.uc-space')]
                                       : [line];
      const unitDelay = unit==='lines'?0:cfg.letterWordDelay;
      let order=targets.map((_,k)=>k); if(cfg.randomize) order.sort(()=>Math.random()-0.5);
      const lineDelay = cfg.parallelLines ? (cumulative + i*cfg.parallelLineStagger) : cumulative;

      targets.forEach((t,j)=>{ const idx=cfg.randomize?order[j]:j; cb(t, lineDelay + idx*unitDelay); });

      if(!cfg.parallelLines){
        cumulative += unit==='lines' ? cfg.delayBetweenLines : (targets.length*unitDelay + cfg.delayBetweenLines);
      }
    });
  }

  // -------- public API --------
  const UCM={
    version:'1.1.0',
    defaults:{...DEFAULTS},
    config(overrides={}){ CONFIG={...CONFIG,...overrides}; this.defaults={...CONFIG}; return this; },

    register(selector,handlers){
      // handlers: {prepare(el,cfg,util), run(el,cfg,util), reset?}
      if(!selector||!handlers||typeof handlers.prepare!=='function'||typeof handlers.run!=='function') return this;
      REGISTRY.set(selector,handlers); return this;
    },

    init(selector){
      // инъекция глушилки Basic для всех зарегистрированных селекторов
      injectBasicNeutralizerFor([...REGISTRY.keys()]);
      // набор элементов к запуску
      const entries = selector
        ? [...d.querySelectorAll(selector)].map(el=>({el,sel:[...REGISTRY.keys()].find(s=>el.matches(s))})).filter(x=>x.sel)
        : [...REGISTRY.keys()].flatMap(sel=>[...d.querySelectorAll(sel)].map(el=>({sel,el})));

      entries.forEach(({sel,el})=>{
        if(el.__ucRan) return;
        const atom=getAtom(el); if(!atom) return;

        // cfg = глобальный CONFIG, переопределённый тумблерами элемента
        const cfg=readTogglesFrom(el, CONFIG);

        // prepare: эффект сам выставит стартовые стили, нужный wrap-режим и т.п.
        REGISTRY.get(sel).prepare(el,cfg,this.util);

        // ждём построения линий и стартуем по триггеру/таймеру
        const start=()=>{ if(el.__ucRan) return;
          if(!atom.__ucLinesBuilt){ requestAnimationFrame(start); return; }
          el.__ucRan=true; neutralizeBasic(el); REGISTRY.get(sel).run(el,cfg,this.util);
        };

        const delay = cfg.preferBasicDelay ? readBasicDelay(el, cfg.baseDelay) : cfg.baseDelay;
        const io=new IntersectionObserver(ents=>{
          ents.forEach(ent=>{
            if(!ent.isIntersecting) return;
            setTimeout(()=>{ start(); io.unobserve(el); }, delay);
          });
        },{threshold:[0,cfg.threshold,1]});
        io.observe(el);

        if(cfg.autoReset && typeof REGISTRY.get(sel).reset==='function'){
          const io2=new IntersectionObserver(ents=>{
            ents.forEach(ent=>{
              if(!ent.isIntersecting && el.__ucRan){
                el.__ucRan=false; REGISTRY.get(sel).reset(el,cfg,this.util); io.observe(el);
              }
            });
          },{threshold:[0,0.01]});
          io2.observe(el);
        }
      });
      return this;
    },

    // экпорт утилит для эффектов в t123
    util:{
      ready,getAtom,toMs,hasBasic,readBasicDelay,neutralizeBasic,injectBasicNeutralizerFor,
      splitWithEntities,ensureWrapped,scheduleByLines,decideUnit,readTogglesFrom
    }
  };

  w.UCM=UCM;
})(window,document);
